\section{逻辑亦数据}
% 从程序执行的视角开始，引入数据是如何编码逻辑的
\subsection{逻辑门}

我们不妨将视角从拟合上短暂地移开，我相信理解逻辑和数据的关系多少也会帮助我们理解神经网络。读者或许好奇过，计算是如何完成的呢？在讨论这个问题之前，先来做一个约定，我们将 0 视作\textoverset{False}{假}，1 视作\textoverset{True}{真}\footnote{逻辑0/1：在物理上，逻辑 0 由\textoverset{Low}{低电平}表示，逻辑 1 由\textoverset{High}{高电平}表示，TTL 和 CMOS 电路各有多种电压标准，感兴趣的读者可以自行学习电路的知识。}。先来看看几种最简单的逻辑运算。

\begin{enumerate}
    \item \textoverset{Not}{非}（数学写法：$\neg$，C 语言写法：\texttt{!}，Python 写法：\texttt{not}）
    
    非是一元运算符，它只有一个输入，输出与输入相反，其中
    \[
        \neg 0 = 1, \neg 1 = 0
    \]
    也就是说 $\neg x = 1 - x$，$x$ 与 $\neg x$ 是互补的。如果你看逻辑 0, 1 仍然感觉不太自然，你可以把它想成 False = not True, True = not False。

    \item \textoverset{And}{与}（数学写法：$\land$，C 语言写法：\texttt{\&\&}，Python 写法：\texttt{and}）
    
    与是二元运算符，它有两个输入，仅当两输入都为 1 时输出为 1，否则输出为 0，从真值表\footnote{真值表：逻辑运算的输出与输入的关系表。}就可以看出这一点：
    \[
        \begin{array}{ccc}
            \hline
            x & y & x \land y \\
            \hline
            0 & 0 & 0 \\
            0 & 1 & 0 \\
            1 & 0 & 0 \\
            1 & 1 & 1 \\
            \hline
        \end{array}
    \]
    这与乘法的结果是一样的，所以有时也会省去和的符号，使用 $xy$ 表示 $x \land y$。
    
    \item \textoverset{Or}{或}（数学写法：$\lor$，C 语言写法：\texttt{||}，Python 写法：\texttt{or}）
    
    或是二元运算符，它有两个输入，仅当两输入都为 0 时输出为 0，否则输出为 1，真值表如下：
    \[
        \begin{array}{ccc}
            \hline
            x & y & x \lor y \\
            \hline
            0 & 0 & 0 \\
            0 & 1 & 1 \\
            1 & 0 & 1 \\
            1 & 1 & 1 \\
            \hline
        \end{array}
    \]
\end{enumerate}

在图上这些运算一般会这样表示：
\begin{figure}[H]
    \centering
    \includegraphics[width=0.2\textwidth]{img/not_gate.png}\quad
    \includegraphics[width=0.2\textwidth]{img/and_gate.png}\quad
    \includegraphics[width=0.2\textwidth]{img/or_gate.png}
    \caption{逻辑门：从左到右分别为非门、与门、或门}
\end{figure}

看起来这只是一些非常简单的运算，但是基本上有这些就可以构建出所有的计算\footnote{所有的运算：这里指的是\textoverset{Turing Completeness}{图灵完备性}，如果你想深入了解，可以在 Steam 上购买一个叫做 \uhref{https://store.steampowered.com/app/1444480/Turing_Complete/}{Turing Complete} 的硬核游戏，推荐游玩。}。例如\textoverset{Exclusive Or}{异或}运算表示两个输入中有且仅有一个为真。最粗暴简单的方法是列出它为 1 的所有情况：$(x\land \neg y) \lor (\neg x \land y)$。这样我们就可以用非、与、或门来构建出一个异或门。

虽然它可以完成“所有的运算”，但是具体来说，比如有读者可能要问，如果我想计算加法，它应该怎么办呢？既然逻辑上只有两个值，那么自然地计算机就要使用二进制来表示数字了。二进制的加法非常简单，就以 $5+3$ 为例，我们可以这样计算：
\[
    \begin{array}{rr}
        &101 \\
        + & 011 \\
        \hline
        & 1000
    \end{array}
\]

逻辑门又是如何完成这一过程的呢？我们将它拆解成一个个小问题。当加到某一位时，我们需要考虑三个数：两个加数和进位。分成 $2^3 = 8$ 种情况
\[
    \begin{array}{cccccc|cccccc}
        \hline
        \overset{\text{加数1}}{x} & \overset{\text{加数2}}{y} & \overset{\text{后方进位}}{c} & \overset{\text{二进制位}}{s} & \overset{\text{向前进位}}{c'} & \text{out} &
        \overset{\text{加数1}}{x} & \overset{\text{加数2}}{y} & \overset{\text{后方进位}}{c} & \overset{\text{二进制位}}{s} & \overset{\text{向前进位}}{c'} & \text{out}\\
        \hline
        0 & 0 & 0 & 0 & 0 & 0&
        0 & 0 & 1 & 1 & 0 & 1\\
        0 & 1 & 0 & 1 & 0 & 1&
        0 & 1 & 1 & 0 & 1 & 2\\
        1 & 0 & 0 & 1 & 0 & 1&
        1 & 0 & 1 & 0 & 1 & 2\\
        1 & 1 & 0 & 0 & 1 & 2&
        1 & 1 & 1 & 1 & 1 & 3\\
        \hline
    \end{array}
\]

每一个输出的位都可以通过输入的逻辑运算，用一定的电路连接表示，把多个电路串起来\footnote{串起来：对于加法这个例子，在网上\uhref{https://www.bing.com/search?q=\%E5\%85\%A8\%E5\%8A\%A0\%E5\%99\%A8}{搜索全加器}就可以很容易地搜到。}，就可以完成加法了。本质上我们的计算机 CPU 就是由这样的门电路与接线组成的\footnote{说明：实际上制造中，与非门、或非门使用更多，因为它们有更方便制造、体积较小、功耗低等优势。}。一个 CPU 需要大量门电路组合形成，现代的 CPU 包含数十亿个门电路，而一个门又由若干个微型的晶体管构成。为了让电路精确地实现我们预期的功能，需要精准地将电路雕刻在硅片上，这就是光刻技术如此重要的原因。但是山在那，总有人会去登的。\footnote{山在那，总有人会去登：语出刘慈欣的短篇小说\uhref{https://zhiqiang.org/resource/liucixin-mountain.html}{山}，写到大量的微晶体管以精妙地排布构成电路让我想起小说中的硅基生物，如果看到这里看累了不妨去看看小说放松一下吧。}

\subsection{程序是怎么执行起来的}
\subsection{位运算与bit-flag}